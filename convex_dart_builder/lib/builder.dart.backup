import 'dart:async';
import 'dart:io';
import 'dart:math';
import 'dart:convert';
import 'package:path/path.dart' as path;
import 'package:build/build.dart';
import 'package:convex_dart_builder/src/types.dart';
// ignore: implementation_imports
import 'package:build_runner_core/src/generate/build_step_impl.dart';

/// Returns a [Builder] for router generation
Builder convexDartBuilder(BuilderOptions options) {
  if (options.config['input_file'] == null) {
    throw Exception(
      'convex_dart_builder requires that the input_file option is set in the build.yaml file',
    );
  }
  return ConvexDartBuilder(options);
}

class ConvexDartBuilder extends Builder {
  final BuilderOptions options;

  ConvexDartBuilder(this.options);

  @override
  FutureOr<void> build(BuildStep buildStep) async {
    if (buildStep.inputId.path != options.config['input_file']) {
      return;
    }
    // Read the schema.json file
    final contents = await buildStep.readAsString(buildStep.inputId);

    // Get the absolute path to the schema.json file
    final buildStepImpl = buildStep as BuildStepImpl;
    final schemaPath = buildStepImpl.assetPathProvider.pathFor(
      buildStep.inputId,
    );
    // Get a list of all the .dart files in the lib directory
    final libPath = path.dirname(schemaPath);
    final libDir = Directory(libPath);
    // Wipe any existing dart files
    await wipeDartFiles(libDir);

    print("DEBUG: Starting schema parsing...");
    
    // Parse JSON manually first to debug
    Map<String, dynamic> jsonData;
    try {
      jsonData = jsonDecode(contents) as Map<String, dynamic>;
      print("DEBUG: JSON parsed successfully");
    } catch (e) {
      print("ERROR: Failed to parse JSON: $e");
      rethrow;
    }

    // Check functions array
    if (jsonData['functions'] is List) {
      final functions = jsonData['functions'] as List;
      print("DEBUG: Found ${functions.length} functions");
      
      // Check each function for args field - only show missing ones
      int missingArgsCount = 0;
      for (int i = 0; i < functions.length; i++) {
        final func = functions[i];
        if (func is Map<String, dynamic>) {
          final identifier = func['identifier'] ?? 'unknown';
          if (!func.containsKey('args')) {
            missingArgsCount++;
            print("ERROR: Function at index $i (identifier: $identifier) is missing 'args' field");
            print("ERROR: Function keys: ${func.keys.toList()}");
            
            // Only show the first few missing args to avoid overflow
            if (missingArgsCount <= 3) {
              print("ERROR: Function content: ${jsonEncode(func)}");
            }
          }
        } else {
          print("ERROR: Function at index $i is not a Map: ${func.runtimeType}");
        }
      }
      print("DEBUG: Functions missing args: $missingArgsCount");
    } else {
      print("ERROR: 'functions' field is not a List or is missing");
    }

    print("DEBUG: Attempting FunctionsSpecMapper.fromJson...");
    final FunctionsSpec functionsSpec;
    try {
      functionsSpec = FunctionsSpecMapper.fromJson(contents);
      print("DEBUG: FunctionsSpecMapper.fromJson succeeded!");
    } catch (e) {
      print("ERROR: FunctionsSpecMapper.fromJson failed: $e");
      print("ERROR: Full schema content length: ${contents.length}");
      rethrow;
    }

    final clientBuildContext = ClientBuildContext();
    await functionsSpec.build(clientBuildContext);
    for (final entry in clientBuildContext.outputs.entries) {
      final filePath = path.join(libPath, entry.key);
      final file = File(filePath);

      await file.create(recursive: true);
      await file.writeAsString(entry.value);
    }

    // Generate a _ignore.dart file to prevent build_runner from ignoring rebuilds
    final assetId = buildStep.inputId.changeExtension("_ignore.dart");
    await buildStep.writeAsString(
      assetId,
      "// Generated by convex_dart_builder ${Random().nextInt(1000000)}",
    );
  }

  @override
  Map<String, List<String>> get buildExtensions => {
    ".json": ["**", "_ignore.dart"],
  };
}

Future<void> wipeDartFiles(Directory dir) async {
  await for (final file in dir.list(recursive: true)) {
    if (file is File && file.path.endsWith(".dart")) {
      await file.delete();
    }
  }
}
