// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'dart_value.dart';
import 'dart_value/function.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'lib.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `connected_client`, `handle_direct_function_result`, `internal_action`, `internal_mutation`, `internal_set_auth`, `internal_subscribe`, `new`, `new`, `update_connection_state`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BTreeMap < String , DartValue >>>
abstract class BTreeMapStringDartValue implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BTreeMap < String , Value >>>
abstract class BTreeMapStringValue implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartQuerySubscriber>>
abstract class DartQuerySubscriber
    implements RustOpaqueInterface, QuerySubscriber {
  @override
  Future<void> onUpdate({required DartFunctionResult value});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MobileConvexClient>>
abstract class MobileConvexClient implements RustOpaqueInterface {
  /// Executes an action on the Convex backend.
  Future<DartValue> action({
    required String name,
    required BTreeMapStringValue args,
  });

  /// Get the current connection state
  ConnectionState getConnectionState();

  /// Marks the connection as disconnected.
  ///
  /// Call this when the WebSocket connection drops (detected via subscription stream ending).
  /// This will notify Dart so it can attempt to reconnect when internet is available.
  Future<void> markDisconnected();

  /// Executes a mutation on the Convex backend.
  Future<DartValue> mutation({
    required String name,
    required BTreeMapStringValue args,
  });

  /// Creates a new [MobileConvexClient].
  ///
  /// The internal [ConvexClient] doesn't get created/connected until the
  /// first public method call that hits the Convex backend.
  ///
  /// The `client_id` should be a string representing the name and version of
  /// the foreign client.
  factory MobileConvexClient({
    required String deploymentUrl,
    required String clientId,
  }) => RustLib.instance.api.crateMobileConvexClientNew(
    deploymentUrl: deploymentUrl,
    clientId: clientId,
  );

  /// Executes a query on the Convex backend.
  Future<DartValue> query({
    required String name,
    required BTreeMapStringValue args,
  });

  /// Reconnects the client by dropping the existing connection and creating a new one.
  ///
  /// Call this when the WebSocket connection becomes stale (e.g., after app backgrounding).
  /// The next query/mutation/action will establish a fresh connection.
  Future<void> reconnect();

  /// Provide an OpenID Connect ID token to be associated with this client.
  ///
  /// Doing so will share that information with the Convex backend and a valid
  /// token will give the backend knowledge of a logged in user.
  ///
  /// Passing [None] for the token will disassociate a previous token,
  /// effectively returning to a logged out state.
  Future<void> setAuth({String? token});

  /// Register a callback to be notified of connection state changes.
  ///
  /// The callback will be called whenever the WebSocket connection state changes
  /// (connected, disconnected, reconnecting).
  Future<void> setConnectionStateCallback({
    required FutureOr<void> Function(ConnectionState) callback,
  });

  /// Subscribe to updates to a query against the Convex backend.
  ///
  /// The [QuerySubscriber] will be called back with initial query results and
  /// it will continue to get called as the underlying data changes.
  ///
  /// The returned [SubscriptionHandle] can be used to cancel the
  /// subscription.
  Future<SubscriptionHandle> subscribe({
    required String name,
    required BTreeMapStringValue args,
    required FutureOr<void> Function(DartFunctionResult) onUpdate,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SubscriptionHandle>>
abstract class SubscriptionHandle implements RustOpaqueInterface {
  /// Cancels the subscription by sending a cancellation signal.
  void cancel();
}

abstract class QuerySubscriber {
  /// Called when a new update is received
  Future<void> onUpdate({required DartFunctionResult value});
}

@freezed
sealed class ClientError with _$ClientError implements FrbException {
  const ClientError._();

  /// An internal error within the mobile Convex client.
  const factory ClientError.internalError({required String msg}) =
      ClientError_InternalError;

  /// An application-specific error from a remote Convex backend function.
  const factory ClientError.convexError({required DartConvexError err}) =
      ClientError_ConvexError;

  /// An unexpected server-side error from a remote Convex function.
  const factory ClientError.serverError({required String msg}) =
      ClientError_ServerError;
}

/// Connection state enum exposed to Dart
enum ConnectionState {
  /// Client is connected and operational
  connected,

  /// Client has disconnected (WebSocket dropped)
  disconnected,

  /// Client is attempting to reconnect
  reconnecting,
}
